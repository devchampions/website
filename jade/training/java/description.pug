p Do you want to write code that is easy to read and test? Develop real-world Java applications that are easy to maintain? Move fast without compromising quality?

p
	b Then this course is for you.

p During this intensive and practical 2-day workshop, you will learn how to develop 
	strong modern, clean, and maintainable 
	| applications using the latest Java best practices. This is not a trivial Java #{self.javaVersion} course for complete beginners. Here you'll learn real-world stuff from class design and unit testing to large-scale architecture, controlling quality, and getting out of technical debt.


h2 Highlights

ul
	li The course is based on real-world project codebases, stories and examples.

	li The course demos are built using real-world libraries such as Spring, Hibernate, and Guava.

	li The course includes practical Lab work and an optional homework assignment.

	li The course is updated to support Java #{self.javaVersion} additions and functional programming idioms (but is relevant for apps that run on older Java versions).

	li You will get a list of books, videos, GitHub projects to learn from, and lifetime support from Eduards.


h2 What's under the hood?

h3: strong (1/9) Effective code design
ul 
	li Finding the right level of abstraction
	li Using cognitive load as a driver for refactoring
	li Balancing use vs. reuse paradox
	li Understanding reification
	li Avoid Hasty Abstractions (AHA)
	li Do or Die Principle (DoD)
	li KISS, SOLID, DRY, ABS, YAGNI
	li Just-enough design and Lean code


h3: strong (2/9) Effective functions
ul
	li Are lambdas always a good choice?
	li Nulls vs. optionals
	li SLAP principle
	li The Step-down rule
	li Command-query separation
	li Replacing getters with queries
	li Replacing setters with domain-driven methods
	li Making conditional easy to read

h3: strong (3/9) Effective class design
ul
	li Stateful objects or pure functions?
	li Objects or data classes?
	li Anemic or rich domain model?
	li Designing entities
	li Designing value objects
	li Designing domain events / event bus
	li Designing exception class hierarchy

h3: strong (4/9) Effective service layer
ul
	li What is a service layer and why we need it?
	li What's the relation with the domain model?
	li Two approaches to services: procedures and commands
	li Implementing services with PipelinR library
	li Commands / Handlers / Pipelines
	li Cross-cutting concerns (logging, transactions, resilience)
	li Offloading and scheduling work 

h3: strong (5/9) Effective packaging
ul
	li How to group classes?
	li How much layering is needed?
	li Packages vs. modules
	li First Guess Principle
	li Minimum Visibility Principle
	li Common Closure Principle
	li Modularity patterns
	li Dependency management
	li Balancing coupling and cohesion

h3: strong (6/9) Effective persistence
ul
	li DAOs
	li Repositories
	li Unit of Work pattern
	li Transaction management
	li Transactional queue / outbox
	li ACID, locking, and isolation modes
	li CQRS and denormalization
	li Designing Aggregate Roots
	li Combining Hibernate and jOOQ

h3: strong (7/9) Effective validation
ul
	li Secure by design
	li Simple validation
	li Business rule validation
	li Why Bean Validation sucks
	li Bean Validation vs. Fluent Validator
	li Implementing a small validation library

h3: strong (8/9) Effective testing
ul
	li What is a unit?
	li Qualities of a good unit test
	li How to make (finally) TDD work
	li How to test integrations, APIs, concurrency, async code
	li How to test architecture rules and constraints
	li Libraries that simplify testing (Spock, Testcontainers...)

h3: strong (9/9) Effective resilience
ul
	li Fault tolerance patterns
	li Retries
	li Timeouts
	li Bulkheads
	li Rate limiting
	li Circuit breakers
	li Hystrix vs. Resilience4j vs. Failsafe

p Ready to upgrade your coding skills? Join in!

style.
	h3 {
		font-size: 1.5em;
		margin-top: 50px !important;
	}